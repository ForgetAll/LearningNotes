CAP 原理：分布式系统在可用性、一致性和分区容错性上无法兼得，由于分区容错无法避免，所以一致性和可用性难以同时成立。

缓存系统的数据一致性通常包括持久化层和缓存的一致性、以及多级缓存之间的一致性。持久化层和缓存层的一致性问题也通常被称为双写一致性问题。

对于一致性来说，包含强一致性和弱一致性。强一致性保证写入后立即可以读取，弱一致性则不保证立即可以读取写入后的值。



### 保证最终一致性的策略（Cache Policy）

#### Cache-Aside

![示意图](https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvaulG1WsztCXujT0qDxALxwEy8knbFcMB7NoiajEYjxo04ww5kmKIOyicbnpbMD0kz3N57EzT4H46xkQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

读请求中，首先请求缓存，若缓存命中（ cache hit ），则直接返回缓存中的数据；若缓存未命中（ cache miss ），则查询数据库并将查询结果更新至缓存，然后返回查询出的数据（ demand-filled look-aside ）。在写请求中，先更新数据库，再删除缓存（write-invalidate）



##### Q1：为什么删除缓存，而不是更新缓存？

缓存对应的结果如果需要大量计算、查询才能得到，在写操作中更新缓存的动作将会是不小的开销。写操作较多时，可能会在更新还没被读到时，又再次被更新（缓存扰动）。读请求未命中再更新，符合懒加载思路。删除缓存的操作不仅是幂等，可以在发生异常时重试，而且写-删除和读-更新在语义上更加对称。

数据不一致问题，并发写请求，线程 1、2 读更新了数据库（2 在 1 之后更新），由于网络延迟原因，线程 1 在 2 之后更新缓存，导致数据库和缓存数据不一致。



##### Q2：为什么先更新数据库，而不是先删除缓存？

并发场景下，线程 1 发起写请求，先删除缓存，还未写入数据库，线程 2 发起读请求，未命中缓存，读到旧数据并写入缓存，此时线程 1 写入数据库，则缓存与数据库数据不一致。



##### Q3：如果先删缓存，再更新数据库，如何解决一致性问题？

为了避免读写并发可能带来的缓存脏数据，提出了延时双删策略，在更新数据库之后，延迟一段时间再次删除缓存。显而易见的是，无论延迟如何预估设置，都很难和读请求完成时间点准确衔接。



##### Q4：Cache-Aside 存在数据不一致的可能吗？

线程 1 的读请求未命中缓存，线程 2 的写请求更新数据库，线程 1 的读请求更新缓存操作晚于线程 2 写请求的删除缓存操作，最终写入缓存的是来自线程 1 的旧值，写入数据库的是来自线程 2 的新值。

这种场景的出现，不仅需要缓存失效且读写并发执行，而且还需要读请求查询数据库的执行早于写请求更新数据库，同时读请求的执行完成晚于写请求。足以见得，这种不一致场景产生的条件非常严格，在实际的生产中出现的可能性较小。

### 总结

读多写少的场景下，可以采用“Cache-Aside”结合消费数据库日志做补偿的方案，写多的场景下，可以采用 “Write-Through 结合分布式锁” 的方案








